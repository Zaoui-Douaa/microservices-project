pipeline {
    agent any

    environment {
        NEXUS_URL = 'http://localhost:8081'
        NEXUS_REPO = 'maven-releases'
        DOCKER_HUB_CRED = credentials('docker-hub-credentials')
        IMAGE_NAME = "douaxx"
        IMAGE_TAG = "1.0.0"
        SONAR_SCANNER_HOME = tool 'SonarQubeScanner'
    }

    stages {
        stage('Build JARs') {
            steps {
                sh 'jenkins/scripts/build_jars.sh'
            }
        }

        stage('SonarQube') {
            steps {
                withCredentials([string(credentialsId: 'ms-token-sonarqube', variable: 'SONAR_TOKEN')]) {
                    withSonarQubeEnv('sonarqube') {
                        sh '''
                            cd products-service
                            mvn clean verify jacoco:report

                            ${SONAR_SCANNER_HOME}/bin/sonar-scanner \
                                -Dsonar.projectKey=microservices-project \
                                -Dsonar.sources=src/main/java \
                                -Dsonar.java.binaries=target/classes \
                                -Dsonar.coverage.jacoco.xmlReportPaths=target/site/jacoco/jacoco.xml \
                                -Dsonar.host.url=$SONAR_HOST_URL \
                                -Dsonar.login=$SONAR_TOKEN
                        '''
                    }
                }
            }
        }

        stage("Quality Gate") {
            steps {
                timeout(time: 1, unit: 'HOURS') {
                    script {
                        def qg = waitForQualityGate abortPipeline: false
                        if (qg.status != 'OK') {
                            echo "Quality Gate failed with status: ${qg.status}"
                            mail to: 'zaouidoa9@gmail.com',
                                subject: "Quality Gate failed",
                                body: """\
                                    Quality Gate failed with status: ${qg.status} for :

                                    Jenkins Pipeline Failed: ${env.JOB_NAME} #${env.BUILD_NUMBER}

                                    Check details and console output:
                                    ${env.BUILD_URL}

                                    Action is required.
                                    """

                        }else {
                            echo "✅ Quality Gate passed."
                            env.QUALITY_GATE_PASSED = "true"  // Marquer comme réussi
                        }
                }
            }
        }
        }

        stage('Deploy JARs to Nexus') {
            steps {
                sh 'jenkins/scripts/deploy_jars.sh'
            }
        }
/*
        stage('Start Databases') {
            steps {
                sh 'jenkins/scripts/start_databases.sh'
            }
        }

        stage('Wait for Databases Ready') {
            steps {
                script {
                    waitForContainerHealth('keycloak', 'pg_isready -U keycloak')
                    waitForContainerHealth('products-service', "mongo --username root --password root --eval \"db.adminCommand('ping')\"")
                    waitForContainerHealth('brands-service', 'mysqladmin ping -u root -proot')
                }
            }
        }

        stage('Start keycloak and make it ready') {
            steps {
                script {
                    sh 'docker-compose up -d keycloak'
                    waitForLogReady('keycloak', 'started in')
                }
            }
        }

        stage('Start Zookeeper and make it ready') {
            steps {
                script {
                    sh 'docker-compose up -d zookeeper'
                    waitForLogReady('zookeeper', 'binding to port')
                }
            }
        }

        stage('Start kafka and make it ready') {
            steps {
                script {
                    sh 'docker-compose up -d kafka'
                    waitForLogReady('kafka', 'started')
                }
            }
        }

        stage('Start kafdrop and make it ready') {
            steps {
                script {
                    sh 'docker-compose up -d kafdrop'
                }
            }
        }

        stage('Start Prometheus and make it ready') {
            steps {
                script {
                    sh 'docker-compose up -d prometheus'
                    waitForLogReady('prometheus', 'Server is ready to receive web requests')
                }
            }
        }

        stage('Start Grafana and make it ready') {
            steps {
                script {
                    sh 'docker-compose up -d grafana'
                    waitForHttpService('http://localhost:3000/api/health')
                }
            }
        }

        stage('Build and Run Config Server') {
            steps {
                sh 'jenkins/scripts/build_run_config_server.sh'
                waitForHttpService('http://localhost:8088/actuator/health')
            }
        }

        stage('Build and Run Eureka Server') {
            steps {
                sh 'jenkins/scripts/build_run_eureka_server.sh'
                waitForHttpService('http://localhost:8761/actuator/health')
            }
        }

        stage('Start Gateway and make it ready') {
            steps {
                script {
                    sh 'jenkins/scripts/build_run_gateway.sh'
                    waitForHttpService('http://localhost:8888/actuator/health')
                }
            }
        }

        stage('Build and Run Microservices') {
            steps {
                sh 'jenkins/scripts/build_run_microservices.sh'
            }
        }
    stage('Docker Image - config-server') {
        steps {
            echo 'Création de l’image Docker pour config-server :'
            dir('config-server') {  // se placer dans le dossier config-server
                sh 'docker build -t $IMAGE_NAME/config-server:$IMAGE_TAG .'
            }
        }
    }

    stage('Docker Hub - config-server') {
        steps {
            echo 'Push de l’image config-server vers Docker Hub :'
            sh '''
                docker login -u $DOCKER_HUB_CRED_USR -p $DOCKER_HUB_CRED_PSW
                docker push $IMAGE_NAME/config-server:$IMAGE_TAG
            '''
        }
    }
*/
    }
    post {
        success {
            echo 'Pipeline completed successfully. All services are built, deployed to Nexus, and running.'
        }
        failure {
            echo 'Pipeline failed.'
            mail to: 'zaouidoa9@gmail.com',
                subject: "Jenkins Pipeline Failed: ${env.JOB_NAME} #${env.BUILD_NUMBER}",
                body: """\
                    The Jenkins pipeline for ${env.JOB_NAME} has failed.

                    Check details and console output:
                    ${env.BUILD_URL}

                    Action is required.
                    """
        }
    }
}

def waitForHttpService(url) {
    timeout(time: 3, unit: 'MINUTES') {
        waitUntil {
            script {
                def status = sh(
                    script: "curl -s ${url} | grep '\"status\":\"UP\"' || true",
                    returnStatus: true
                )
                if (status == 0) {
                    echo "Service at ${url} is UP"
                    return true
                } else {
                    echo "Waiting for service at ${url} to be UP..."
                    return false
                }
            }
        }
    }
}


def waitForContainerHealth(container, checkCommand) {
    timeout(time: 3, unit: 'MINUTES') {
        waitUntil {
            script {
                def status = sh(
                    script: "docker exec ${container} ${checkCommand} || true",
                    returnStatus: true
                )
                return (status == 0)
            }
        }
    }
}

def waitForLogReady(container, logKeyword) {
    timeout(time: 3, unit: 'MINUTES') {
        waitUntil {
            script {
                def found = sh(
                    script: "docker logs ${container} | grep '${logKeyword}' || true",
                    returnStatus: true
                )
                return (found == 0)
            }
        }
    }
}